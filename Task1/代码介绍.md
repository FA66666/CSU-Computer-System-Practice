下面我们结合具体的代码块，来详细讲解 MASM 汇编计算器各个功能模块的实现。

------



## 1. 主程序入口 (`main` 过程)



`main` 过程是程序执行的起点，它负责设置环境并进入主菜单循环。

Code snippet

```assembly
main proc
    ; 获取标准输出和输入句柄
    invoke GetStdHandle, STD_OUTPUT_HANDLE        ; 获取标准输出句柄
    mov    hConsoleOutput, eax                    ; 保存输出句柄到变量
    invoke GetStdHandle, STD_INPUT_HANDLE         ; 获取标准输入句柄
    mov    hConsoleInput, eax                     ; 保存输入句柄到变量

MainMenuLoop:
    invoke crt_system, addr szCls                 ; 调用 system("cls") 清屏命令
    ; 输出主菜单到控制台
    invoke WriteConsoleA, hConsoleOutput, addr szMenu, szMenuLen, addr dwCharsRead, NULL
    push   edi                                    ; 保存 edi 寄存器
    mov    edi, offset cInputBuffer               ; edi 指向输入缓冲区
    mov    ecx, sizeof cInputBuffer               ; ecx = 缓冲区大小
    xor    al, al                                 ; al = 0
    rep    stosb                                  ; 清空输入缓冲区（全部置0）
    pop    edi                                    ; 恢复 edi 寄存器
    ; 读取用户输入到 cInputBuffer
    invoke ReadConsoleA, hConsoleInput, addr cInputBuffer, sizeof cInputBuffer, addr dwCharsRead, NULL
    ; 根据用户输入字符进行跳转
    cmp    cInputBuffer[0], '1'                  ; 判断输入是否为 '1'
    je     CallCalculate                          ; 是则跳转到表达式计算
    cmp    cInputBuffer[0], '2'                  ; 判断输入是否为 '2'
    je     CallViewHistory                        ; 是则跳转到历史查看
    cmp    cInputBuffer[0], '3'                  ; 判断输入是否为 '3'
    je     CallCombineHistory                     ; 是则跳转到历史组合
    cmp    cInputBuffer[0], '4'                  ; 判断输入是否为 '4'
    je     CallClearHistory                       ; 是则跳转到清空历史
    cmp    cInputBuffer[0], '5'                  ; 判断输入是否为 '5'
    je     DoExit                                 ; 是则退出程序
    jmp    MainMenuLoop                           ; 其他输入，重新循环主菜单

CallCalculate:
    call   DoCalculate
    jmp    MainMenuLoop
CallViewHistory:
    call   DoViewHistory
    jmp    MainMenuLoop
CallCombineHistory:
    call   DoHistoryCalculation
    jmp    MainMenuLoop
CallClearHistory:
    call   DoClearHistory
    jmp    MainMenuLoop

DoExit:
    invoke ExitProcess, 0
main endp
```

- **控制台句柄获取**：`invoke GetStdHandle, STD_OUTPUT_HANDLE` 和 `invoke GetStdHandle, STD_INPUT_HANDLE` 分别获取标准输出和标准输入的句柄。这些句柄是 Windows API 中用于控制台 I/O 操作的关键。
- **主循环 (`MainMenuLoop`)**：程序的核心是这个无限循环。每次循环开始时，`crt_system, addr szCls` 会执行 `cls` 命令清屏。
- **菜单显示**：`WriteConsoleA` 用于将 `szMenu` 中定义的菜单字符串写入控制台。
- **用户输入**：`ReadConsoleA` 从控制台读取用户输入到 `cInputBuffer`。在读取之前，`cInputBuffer` 会被 `rep stosb` 指令清空，确保每次输入都是干净的。
- **分支跳转**：通过一系列的 `cmp` (比较) 和 `je` (相等则跳转) 指令，程序根据 `cInputBuffer[0]`（用户输入的第一个字符）来决定调用哪个子程序。
- **返回主菜单**：每个功能子程序执行完毕后，通常会 `jmp MainMenuLoop` 返回主菜单，允许用户选择其他操作，直到选择退出 (`DoExit`)，`ExitProcess` 才会终止程序。

------



## 2. 表达式计算 (`DoCalculate` 和 `PerformCalculation` 过程)

### 2.1 顶层计算控制 (`DoCalculate`)

`DoCalculate` 过程是用户选择“计算表达式”时调用的入口。

```assembly
DoCalculate proc
    invoke StdOut, addr szPromptExpr ; 提示输入表达式
    push   edi
    mov    edi, offset szExprBuffer
    mov    ecx, sizeof szExprBuffer
    xor    al, al
    rep    stosb ; 清空表达式缓冲区
    pop    edi
    invoke ReadConsoleA, hConsoleInput, addr szExprBuffer, sizeof szExprBuffer, addr dwCharsRead, NULL ; 读取表达式
    call   PerformCalculation ; 计算并显示步骤
    call   SaveExpressionToFile ; 保存到历史
    invoke StdOut, addr szPressAnyKey
    invoke _getch
    ret
DoCalculate endp
```

- **输入提示与读取**：`StdOut` 打印提示，`szExprBuffer` 缓冲区被清空，然后 `ReadConsoleA` 读取用户输入的表达式。
- **核心计算**：`call PerformCalculation` 是整个计算过程的真正核心。
- **历史记录**：`call SaveExpressionToFile` 将当前计算的表达式追加保存到历史文件中。
- **暂停**：`_getch` 函数暂停程序，等待用户按任意键继续。



### 2.2 核心计算逻辑 (`PerformCalculation`)

`PerformCalculation` 是实现表达式计算的关键，它结合了 **Shunting-yard 算法**（将中缀表达式转换为逆波兰表达式）和**逆波兰表达式求值**。

```
PerformCalculation proc uses ebx esi edi
    LOCAL  tempResult:REAL8
    LOCAL  op1:REAL8
    LOCAL  op2:REAL8
    LOCAL  currentPrec:DWORD
    LOCAL  stackPrec:DWORD
    LOCAL  pOp1Str:DWORD
    LOCAL  pOp2Str:DWORD
    LOCAL  pResultStr:DWORD
    LOCAL  pOperatorStr:DWORD

    mov    pCurrentChar, offset szExprBuffer ; 初始化当前字符指针
    mov    outputQueueSize, 0           ; 初始化输出队列长度
    mov    opStackTop, 0                ; 初始化运算符栈顶
    mov    g_prevTokenType, TOKEN_TYPE_LPAREN ; 初始上一个记号类型为左括号，以便正确识别开头的一元负号

; Shunting-yard 算法主循环：中缀转后缀
ShuntingYardLoop:
    call   GetNextToken                 ; 获取下一个记号
    mov    ebx, eax                     ; 将记号类型存储到 ebx
    cmp    ebx, TOKEN_TYPE_END          ; 检查是否为表达式结束
    je     HandleEnd                    ; 如果是，处理结束
    push   ebx                          ; 临时保存当前记号类型
    mov    g_prevTokenType, ebx         ; 更新上一个记号类型
    pop    ebx                          ; 恢复当前记号类型

    cmp    ebx, TOKEN_TYPE_NUMBER       ; 记号是数字
    je     HandleNumber
    cmp    ebx, TOKEN_TYPE_LPAREN       ; 记号是左括号
    je     HandleLParen
    cmp    ebx, TOKEN_TYPE_RPAREN       ; 记号是右括号
    je     HandleRParen
    cmp    ebx, TOKEN_TYPE_ERROR        ; 记号是错误
    je     HandleEnd                    ; 遇到错误也视为结束

HandleOperator:                         ; 处理运算符（加减乘除，一元负号）
    mov    eax, ebx                     ; eax = 当前运算符类型
    call   GetPrecedence                ; 获取当前运算符的优先级
    mov    currentPrec, eax             ; 保存当前优先级

CheckStackTop:
    cmp    opStackTop, 0                ; 栈是否为空？
    je     EndCheckStackTop             ; 空则跳出
    mov    ecx, opStackTop
    dec    ecx
    mov    edx, operatorStack[ecx*4]    ; edx = 栈顶运算符类型
    cmp    edx, TOKEN_TYPE_LPAREN       ; 栈顶是否为左括号？
    je     EndCheckStackTop             ; 是则停止弹出
    mov    eax, edx
    call   GetPrecedence                ; 获取栈顶运算符优先级
    mov    stackPrec, eax               ; 保存栈顶优先级

    mov    eax, stackPrec
    cmp    eax, currentPrec             ; 比较栈顶优先级和当前优先级
    jb     EndCheckStackTop             ; 如果栈顶优先级低于当前优先级，停止弹出（适用于左结合性）

    ; 弹出栈顶运算符到输出队列
    mov    ecx, opStackTop
    dec    ecx
    mov    edx, operatorStack[ecx*4]
    mov    opStackTop, ecx

    mov    ecx, outputQueueSize
    mov    eax, ecx
    imul   eax, SIZEOF OutputToken
    add    eax, offset outputQueue
    mov    [eax].OutputToken.tokenType, edx
    inc    ecx
    mov    outputQueueSize, ecx
    jmp    CheckStackTop                ; 继续检查新的栈顶

EndCheckStackTop:
    ; 将当前运算符压入栈
    mov    ecx, opStackTop
    mov    operatorStack[ecx*4], ebx
    inc    ecx
    mov    opStackTop, ecx
    jmp    ShuntingYardLoop             ; 继续处理下一个记号

HandleNumber:
    mov    ecx, outputQueueSize
    mov    eax, ecx
    imul   eax, SIZEOF OutputToken
    add    eax, offset outputQueue
    mov    [eax].OutputToken.tokenType, ebx ; 设置类型为数字
    fld    currentTokenVal              ; 加载数字值到 FPU 栈
    fstp   [eax].OutputToken.tokenValue ; 存储到输出队列
    inc    ecx
    mov    outputQueueSize, ecx
    jmp    ShuntingYardLoop

HandleLParen:
    mov    ecx, opStackTop
    mov    operatorStack[ecx*4], ebx    ; 左括号压栈
    inc    ecx
    mov    opStackTop, ecx
    jmp    ShuntingYardLoop

HandleRParen:
PopUntilLParen:
    cmp    opStackTop, 0                ; 栈是否为空？ (不匹配的右括号)
    je     ShuntingYardLoop             ; 跳过
    mov    ecx, opStackTop
    dec    ecx
    mov    edx, operatorStack[ecx*4]
    mov    opStackTop, ecx
    cmp    edx, TOKEN_TYPE_LPAREN       ; 是否为左括号？
    je     ShuntingYardLoop             ; 是则匹配成功，跳出循环
    ; 弹出运算符到输出队列
    mov    ecx, outputQueueSize
    mov    eax, ecx
    imul   eax, SIZEOF OutputToken
    add    eax, offset outputQueue
    mov    [eax].OutputToken.tokenType, edx
    inc    ecx
    mov    outputQueueSize, ecx
    jmp    PopUntilLParen               ; 继续弹出

HandleEnd:
PopAllOperators_Loop:
    cmp    opStackTop, 0                ; 栈中是否还有运算符？
    je     EndPopAllOperators           ; 没有则结束
    mov    ecx, opStackTop
    dec    ecx
    mov    edx, operatorStack[ecx*4]
    mov    opStackTop, ecx
    ; 弹出所有剩余运算符到输出队列
    mov    ecx, outputQueueSize
    mov    eax, ecx
    imul   eax, SIZEOF OutputToken
    add    eax, offset outputQueue
    mov    [eax].OutputToken.tokenType, edx
    inc    ecx
    mov    outputQueueSize, ecx
    jmp    PopAllOperators_Loop

EndPopAllOperators:
    invoke StdOut, addr szStepHeader    ; 显示计算步骤标题
    mov    rpnStepStackTop, 0           ; 初始化步骤栈
    mov    pStringPool, offset stringPool ; 初始化字符串池指针

    mov    ecx, 0                       ; ecx 作为 RPN 队列索引
EvaluateRpnLoop:                        ; 逆波兰表达式求值主循环
    cmp    ecx, outputQueueSize         ; 是否处理完所有 RPN 记号？
    jge    EndEvaluateRpnLoop           ; 是则结束

    push   ecx                          ; 保存当前记号索引

    mov    esi, ecx
    imul   esi, SIZEOF OutputToken
    add    esi, offset outputQueue
    mov    edx, [esi].OutputToken.tokenType ; 获取当前 RPN 记号类型

    cmp    edx, TOKEN_TYPE_NUMBER       ; 数字？
    je     EvalNumber
    cmp    edx, TOKEN_TYPE_UNARY_MINUS  ; 一元负号？
    je     EvalUnaryMinus
    jmp    EvalBinaryOp                 ; 否则是二元运算符

EvalNumber:
    fld    [esi].OutputToken.tokenValue ; 加载数字值到 FPU 栈
    mov    edi, pStringPool             ; 准备在字符串池中存储数字字符串
    invoke crt_sprintf, edi, addr szFloatFmt, [esi].OutputToken.tokenValue ; 浮点数转字符串
    mov    ebx, rpnStepStackTop
    mov    rpnStepStack[ebx*4], edi     ; 将数字字符串指针压入步骤栈
    inc    ebx
    mov    rpnStepStackTop, ebx
    invoke crt_strlen, edi             ; 更新字符串池指针，留出空终止符空间
    add    edi, eax
    inc    edi
    mov    pStringPool, edi
    jmp    NextRpnTokenInEval

EvalUnaryMinus:
    fstp   op1                          ; 弹出操作数到 op1
    mov    ebx, rpnStepStackTop
    dec    ebx
    mov    eax, rpnStepStack[ebx*4]
    mov    pOp1Str, eax                 ; 获取操作数字符串指针
    mov    rpnStepStackTop, ebx         ; 弹出操作数字符串指针

    fld    op1                          ; 加载操作数
    fchs                                ; FPU 取反
    fstp   tempResult                   ; 结果存储到 tempResult

    mov    edi, pStringPool
    invoke crt_sprintf, edi, addr szFloatFmt, tempResult ; 结果转字符串
    mov    pResultStr, edi
    invoke crt_printf, addr szStepUnaryFmt, pOp1Str, pResultStr ; 打印步骤
    
    fld    tempResult                   ; 结果压回 FPU 栈
    mov    ebx, rpnStepStackTop
    mov    rpnStepStack[ebx*4], edi     ; 结果字符串指针压回步骤栈
    inc    ebx
    mov    rpnStepStackTop, ebx
    invoke crt_strlen, edi
    add    edi, eax
    inc    edi
    mov    pStringPool, edi
    jmp    NextRpnTokenInEval

EvalBinaryOp:
    fstp   op2                          ; 弹出第二个操作数 (栈顶)
    fstp   op1                          ; 弹出第一个操作数
    mov    ebx, rpnStepStackTop
    dec    ebx
    mov    eax, rpnStepStack[ebx*4]
    mov    pOp2Str, eax                 ; 获取第二个操作数字符串
    dec    ebx
    mov    eax, rpnStepStack[ebx*4]
    mov    pOp1Str, eax                 ; 获取第一个操作数字符串
    mov    rpnStepStackTop, ebx         ; 弹出两个操作数字符串
    
    fld    op1                          ; 加载 op1 到 FPU 栈
    fld    op2                          ; 加载 op2 到 FPU 栈
    
    mov    eax, [esi].OutputToken.tokenType ; 获取运算符类型
    cmp    eax, TOKEN_TYPE_PLUS
    je     do_add
    cmp    eax, TOKEN_TYPE_MINUS
    je     do_sub
    cmp    eax, TOKEN_TYPE_MULTIPLY
    je     do_mul
    
    ; 除法
    mov    pOperatorStr, offset szOpDivide
    fdivp  st(1), st(0)                 ; FPU 除法
    jmp    calc_done

do_add:
    mov    pOperatorStr, offset szOpPlus
    faddp  st(1), st(0)                 ; FPU 加法
    jmp    calc_done
do_sub:
    mov    pOperatorStr, offset szOpMinus
    fsubp  st(1), st(0)                 ; FPU 减法
    jmp    calc_done
do_mul:
    mov    pOperatorStr, offset szOpMultiply
    fmulp  st(1), st(0)                 ; FPU 乘法
    jmp    calc_done

calc_done:
    fstp   tempResult                   ; 弹出 FPU 栈顶结果

    mov    edi, pStringPool
    invoke crt_sprintf, edi, addr szFloatFmt, tempResult ; 结果转字符串
    mov    pResultStr, edi
    
    invoke crt_printf, addr szStepFmt, pOp1Str, pOperatorStr, pOp2Str, pResultStr ; 打印步骤
    
    fld    tempResult                   ; 结果压回 FPU 栈
    mov    ebx, rpnStepStackTop
    mov    rpnStepStack[ebx*4], edi     ; 结果字符串压回步骤栈
    inc    ebx
    mov    rpnStepStackTop, ebx
    invoke crt_strlen, edi
    add    edi, eax
    inc    edi
    mov    pStringPool, edi
    jmp    NextRpnTokenInEval
    
NextRpnTokenInEval:
    pop    ecx                          ; 恢复 ecx
    inc    ecx
    jmp    EvaluateRpnLoop

EndEvaluateRpnLoop:
    invoke StdOut, addr szResultHeader  ; 显示最终结果标题
    fstp   tempResult                   ; 弹出最终结果
    invoke crt_printf, addr szResultFmt, tempResult ; 打印最终结果
    ret
PerformCalculation endp
```

- **Shunting-yard 算法**：
  - **核心思想**：通过一个**输出队列** (`outputQueue`) 和一个**运算符栈** (`operatorStack`) 来实现。
  - **数字**：直接放入 `outputQueue`。
  - **括号**：左括号入栈。右括号则将栈中运算符逐个弹出到 `outputQueue`，直到遇到对应的左括号。
  - **运算符**：当遇到一个运算符时，会比较它与栈顶运算符的**优先级**。如果栈顶运算符的优先级更高或相等（并且是左结合的，这里隐式处理了），则将栈顶运算符弹出到 `outputQueue`。这个过程重复进行，直到栈顶运算符优先级低于当前运算符，或者栈为空，或者栈顶是左括号。然后，当前运算符被压入栈。
  - **表达式结束**：所有记号处理完毕后，将运算符栈中剩余的所有运算符弹出到 `outputQueue`。
  - **`OutputToken` 结构**：`outputQueue` 中存储的是 `OutputToken` 结构，它包含 `tokenType` (记号类型) 和 `tokenValue` (如果是数字)。
- **逆波兰表达式求值**：
  - **核心思想**：使用一个栈（这里是 FPU 栈用于数值计算，`rpnStepStack` 用于存储中间结果的字符串表示）来处理 RPN 表达式。
  - **数字**：遇到数字，将其值推入 FPU 栈。为了打印步骤，同时将其字符串表示推入 `rpnStepStack`。
  - **运算符**：遇到运算符时，从 FPU 栈弹出所需数量的操作数（二元运算符弹出两个，一元负号弹出一个），执行运算，然后将结果推回 FPU 栈。
  - **打印步骤**：在每一步运算后，程序会格式化打印出 "操作数1 运算符 操作数2 = 结果" (或 "neg(操作数) = 结果") 的详细步骤。这需要将浮点数结果转换成字符串，并使用 `pOp1Str`, `pOp2Str`, `pResultStr`, `pOperatorStr` 等局部变量来存储和引用这些字符串。`stringPool` 用于动态分配这些步骤字符串的内存。
  - **最终结果**：当所有 RPN 记号处理完毕，FPU 栈中剩下的唯一值就是最终的计算结果。

------



## 3. 词法分析器 (`GetNextToken` 过程)



`GetNextToken` 负责从表达式字符串中提取下一个“有意义”的单元（记号）。

Code snippet

```
GetNextToken proc
    mov    esi, pCurrentChar            ; esi 指向当前处理的字符

SkipWhitespace:
    mov    al, byte ptr [esi]
    cmp    al, ' '
    je     AdvanceAndRepeat
    cmp    al, 9
    je     AdvanceAndRepeat
    cmp    al, 10
    je     AdvanceAndRepeat
    cmp    al, 13
    je     AdvanceAndRepeat
    jmp    FoundNonWhitespace

AdvanceAndRepeat:
    inc    esi
    jmp    SkipWhitespace

FoundNonWhitespace:
    cmp    byte ptr [esi], 0            ; 字符串结束符
    je     TokenIsEnd

    mov    bl, byte ptr [esi]
    cmp    bl, '0'                      ; 0-9 之间？
    jb     CheckOperators
    cmp    bl, '9'
    ja     CheckDecimalOrOperators      ; 大于 9，可能是小数点
    jmp    TokenIsNumber

CheckDecimalOrOperators:
    cmp    bl, '.'                      ; 是小数点吗？
    je     TokenIsNumber

CheckOperators:
    cmp    bl, '+'
    je     TokenIsPlus
    cmp    bl, '-'
    je     TokenIsMinus                 ; 减号需要特殊处理一元负号
    cmp    bl, '*'
    je     TokenIsMultiply
    cmp    bl, '/'
    je     TokenIsDivide
    cmp    bl, '('
    je     TokenIsLparen
    cmp    bl, ')'
    je     TokenIsRparen
    jmp    TokenIsError                 ; 无法识别的字符

TokenIsNumber:
    invoke crt_atof, esi                ; 字符串转浮点数
    fstp   currentTokenVal

FindEndOfNumber:
    mov    bl, byte ptr [esi]
    cmp    bl, '0'
    jl     NotADigitOrPeriod
    cmp    bl, '9'
    jg     NotADigitOrPeriod
    jmp    IsPartOfNumber
NotADigitOrPeriod:
    cmp    bl, '.'
    jne    EndOfNumberFound
IsPartOfNumber:
    inc    esi
    jmp    FindEndOfNumber
EndOfNumberFound:
    mov    pCurrentChar, esi
    mov    eax, TOKEN_TYPE_NUMBER
    ret

TokenIsPlus:
    inc    esi
    mov    pCurrentChar, esi
    mov    eax, TOKEN_TYPE_PLUS
    ret

TokenIsMinus:                           ; 区分二元减法和一元负号
    mov    eax, g_prevTokenType         ; 检查上一个记号类型
    cmp    eax, TOKEN_TYPE_NUMBER       ; 如果上一个是数字
    je     ReturnBinaryMinus
    cmp    eax, TOKEN_TYPE_RPAREN       ; 或上一个是右括号
    je     ReturnBinaryMinus
    ; 否则就是一元负号
    inc    esi
    mov    pCurrentChar, esi
    mov    eax, TOKEN_TYPE_UNARY_MINUS
    ret
ReturnBinaryMinus:
    inc    esi
    mov    pCurrentChar, esi
    mov    eax, TOKEN_TYPE_MINUS
    ret

TokenIsMultiply:
    inc    esi
    mov    pCurrentChar, esi
    mov    eax, TOKEN_TYPE_MULTIPLY
    ret

TokenIsDivide:
    inc    esi
    mov    pCurrentChar, esi
    mov    eax, TOKEN_TYPE_DIVIDE
    ret

TokenIsLparen:
    inc    esi
    mov    pCurrentChar, esi
    mov    eax, TOKEN_TYPE_LPAREN
    ret

TokenIsRparen:
    inc    esi
    mov    pCurrentChar, esi
    mov    eax, TOKEN_TYPE_RPAREN
    ret

TokenIsEnd:
    mov    eax, TOKEN_TYPE_END
    ret

TokenIsError:
    inc    esi
    mov    pCurrentChar, esi
    mov    eax, TOKEN_TYPE_ERROR
    ret
GetNextToken endp
```

- **`pCurrentChar`**：这是一个全局变量，指向当前正在被词法分析器处理的字符位置。每次 `GetNextToken` 被调用，它都会从 `pCurrentChar` 开始查找记号，并在找到记号后更新 `pCurrentChar`。
- **空白字符跳过**：`SkipWhitespace` 循环检查并跳过空格、Tab、回车、换行等字符。
- **数字识别**：通过检查字符是否在 `'0'` 到 `'9'` 之间或为 `.` 来识别数字。`crt_atof` (ASCII to float) 是 C 运行时库函数，用于将字符串转换为双精度浮点数。
- **运算符/括号识别**：通过一系列 `cmp` 和 `je` 来匹配 `+`, `-`, `*`, `/`, `(`, `)`。
- **一元负号判断**：这是 `-` 运算符的特殊处理。通过检查 `g_prevTokenType`（上一个记号的类型）来确定当前 `-` 是二元减号还是作为数字一部分的一元负号。
  - 如果前一个记号是 **数字** 或 **右括号**，那么当前的 `-` 很可能是一个**二元减号**。
  - 否则（例如表达式开头，或在另一个运算符之后，或在左括号之后），它被视为**一元负号**。
- **返回**：将识别到的记号类型放入 `eax`，如果是数字，其值存储在 `currentTokenVal` 中。

------



## 4. 运算符优先级 (`GetPrecedence` 过程)



Code snippet

```
GetPrecedence proc
    cmp    eax, TOKEN_TYPE_UNARY_MINUS
    je     PrecedenceIs3
    cmp    eax, TOKEN_TYPE_MULTIPLY
    je     PrecedenceIs2
    cmp    eax, TOKEN_TYPE_DIVIDE
    je     PrecedenceIs2
    cmp    eax, TOKEN_TYPE_PLUS
    je     PrecedenceIs1
    cmp    eax, TOKEN_TYPE_MINUS
    je     PrecedenceIs1
    xor    eax, eax ; 其他返回0
    ret
PrecedenceIs1:
    mov    eax, 1 ; + - 优先级1
    ret
PrecedenceIs2:
    mov    eax, 2 ; * / 优先级2
    ret
PrecedenceIs3:
    mov    eax, 3 ; 一元负号优先级3
    ret
GetPrecedence endp
```

- 这个过程接收一个记号类型（在 `eax` 中），并返回其优先级。
- 优先级定义：一元负号 (`3`) > 乘除 (`2`) > 加减 (`1`)。
- 非运算符（如数字、括号）返回优先级 `0`。这个优先级在 Shunting-yard 算法中用于决定运算符的弹出和压入顺序。

------



## 5. 历史记录管理





### 5.1 保存表达式 (`SaveExpressionToFile`)



Code snippet

```
SaveExpressionToFile proc uses edi
    LOCAL  hFile:HANDLE
    LOCAL  dwBytesWritten:DWORD
    invoke CreateFile, addr szHistoryFile, GENERIC_WRITE, FILE_SHARE_READ, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL
    mov    hFile, eax
    cmp    eax, INVALID_HANDLE_VALUE
    je     SaveExit
    invoke SetFilePointer, hFile, 0, NULL, FILE_END ; 定位到文件末尾
    mov    edi, offset szExprBuffer
    mov    ecx, 0
CountLoop:
    cmp    byte ptr [edi+ecx], 0
    je     FoundEnd
    cmp    byte ptr [edi+ecx], 13 ; 检查回车符 (CR)
    je     FoundEnd
    inc    ecx
    jmp    CountLoop
FoundEnd:
    invoke WriteFile, hFile, addr szExprBuffer, ecx, addr dwBytesWritten, NULL ; 写入表达式内容
    invoke WriteFile, hFile, addr szCRLF, 2, addr dwBytesWritten, NULL         ; 写入换行
    invoke CloseHandle, hFile
SaveExit:
    ret
SaveExpressionToFile endp
```

- **文件创建/打开**：`CreateFile` 是 Windows API 函数，用于打开或创建文件。`OPEN_ALWAYS` 确保文件总是被打开，如果不存在则创建。`GENERIC_WRITE` 允许写入。
- **定位文件指针**：`SetFilePointer` 将文件指针移动到文件末尾 (`FILE_END`)，这样新的历史记录就会被追加到文件末尾。
- **获取表达式长度**：一个简单的循环遍历 `szExprBuffer` 直到遇到空终止符 `0` 或回车符 `13`（因为 `ReadConsoleA` 读取的输入通常以 CR+LF 结尾），以获得实际的表达式长度。
- **写入内容**：`WriteFile` 将 `szExprBuffer` 的内容写入文件，然后紧跟着写入 `szCRLF` (回车换行符)，确保每条历史记录占一行。
- **关闭文件**：`CloseHandle` 释放文件句柄。



### 5.2 获取历史行 (`GetHistoryLine`)



Code snippet

```
GetHistoryLine proc uses edi, nLine:DWORD, pBuf:PTR BYTE
    LOCAL  pFile:DWORD
    LOCAL  lineCounter:DWORD
    invoke crt_fopen, addr szHistoryFile, addr szFileReadMode ; 打开历史文件
    mov    pFile, eax
    test   eax, eax
    jz     GetLineFail
    mov    lineCounter, 1
GetLineLoop:
    mov    eax, lineCounter
    cmp    eax, nLine
    je     FoundLine
    invoke crt_fgets, addr lineBuffer, sizeof lineBuffer, pFile ; 读取一行（跳过）
    test   eax, eax
    jz     CloseAndFail
    inc    lineCounter
    jmp    GetLineLoop
FoundLine:
    invoke crt_fgets, pBuf, 256, pFile ; 读取目标行到 pBuf
    test   eax, eax
    jz     CloseAndFail
    invoke crt_strlen, pBuf
    mov    edi, pBuf
    cmp    eax, 0
    je     EndRemoveNL
    cmp    byte ptr [edi+eax-1], 10
    jne    EndRemoveNL
    mov    byte ptr [edi+eax-1], 0 ; 去除换行符
    dec    eax
    cmp    eax, 0
    je     EndRemoveNL
    cmp    byte ptr [edi+eax-1], 13
    jne    EndRemoveNL
    mov    byte ptr [edi+eax-1], 0 ; 去除回车符
EndRemoveNL:
    invoke crt_fclose, pFile
    mov    eax, 1
    ret
CloseAndFail:
    invoke crt_fclose, pFile
GetLineFail:
    mov    eax, 0
    ret
GetHistoryLine endp
```

- **文件打开**：使用 `crt_fopen` 以只读模式 (`"r"`) 打开 `history.txt`。
- **逐行读取**：循环调用 `crt_fgets` 来读取文件中的每一行。
- **行号匹配**：`lineCounter` 记录当前读取到的行号。当 `lineCounter` 等于 `nLine`（目标行号）时，表示找到了目标行。
- **读取目标行**：找到目标行后，再次调用 `crt_fgets` 将该行内容读取到 `pBuf`。
- **去除换行符**：由于 `crt_fgets` 会包含行末的 `CRLF` (回车换行)，这里手动检查并将其替换为字符串终止符 `0`，确保 `pBuf` 中是纯净的表达式字符串。
- **错误处理**：如果文件打开失败或在读取过程中遇到文件结束/错误，则返回 `0`。



### 5.3 清空历史 (`DoClearHistory`)



Code snippet

```
DoClearHistory proc
    invoke DeleteFile, addr szHistoryFile ; 删除历史文件
    invoke StdOut, addr szHistoryCleared ; 提示已清空
    invoke StdOut, addr szPressAnyKey
    invoke _getch
    ret
DoClearHistory endp
```

- **文件删除**：直接调用 Windows API 的 `DeleteFile` 函数，删除 `history.txt` 文件。这是清空历史记录最直接的方式。
- **用户反馈**：打印提示信息并等待用户按键。



### 5.4 分页查看历史 (`DoViewHistory`)



Code snippet

```
DoViewHistory proc uses ebx esi edi
    LOCAL  pFile:DWORD
    LOCAL  totalLines:DWORD
    LOCAL  currentPage:DWORD
    LOCAL  totalPages:DWORD
    LOCAL  lineCounter:DWORD
    LOCAL  linesToSkip:DWORD
    LOCAL  linesToPrint:DWORD
    LOCAL  charInput:DWORD

    ; 第一步：统计总行数
    invoke crt_fopen, addr szHistoryFile, addr szFileReadMode
    mov    pFile, eax
    test   eax, eax
    jz     HistoryIsEmpty
    mov    totalLines, 0
CountLinesLoop:
    invoke crt_fgets, addr lineBuffer, sizeof lineBuffer, pFile
    test   eax, eax
    jz     DoneCounting
    inc    totalLines
    jmp    CountLinesLoop
DoneCounting:
    invoke crt_fclose, pFile
    cmp    totalLines, 0
    je     HistoryIsEmpty

    ; 第二步：计算总页数
    mov    eax, totalLines
    xor    edx, edx
    mov    ebx, PAGE_SIZE
    div    ebx
    test   edx, edx
    jz     NoRemainder
    inc    eax
NoRemainder:
    cmp    eax, 0
    jne    PagesExist
    mov    eax, 1
PagesExist:
    mov    totalPages, eax
    mov    currentPage, 1

    ; 第三步：分页主循环
PagingLoop:
    invoke crt_system, addr szCls
    invoke StdOut, addr szHistoryHeader

    ; 重新打开文件，跳转到当前页
    invoke crt_fopen, addr szHistoryFile, addr szFileReadMode
    mov    pFile, eax
    test   eax, eax
    jz     ExitPaging
    mov    eax, currentPage
    dec    eax
    mov    ebx, PAGE_SIZE
    mul    ebx
    mov    linesToSkip, eax
    mov    lineCounter, 0
SkipLinesLoop:
    mov    eax, lineCounter
    cmp    eax, linesToSkip
    jge    DoneSkipping
    invoke crt_fgets, addr lineBuffer, sizeof lineBuffer, pFile ; 跳过前面行
    inc    lineCounter
    jmp    SkipLinesLoop
DoneSkipping:
    mov    linesToPrint, 0
PrintPageLoop:
    mov    eax, linesToPrint
    cmp    eax, PAGE_SIZE
    jge    DonePrintingPage
    invoke crt_fgets, addr lineBuffer, sizeof lineBuffer, pFile
    test   eax, eax
    jz     DonePrintingPage
    mov    eax, linesToSkip
    add    eax, linesToPrint
    inc    eax
    invoke crt_printf, addr szHistoryLineFmt, eax, addr lineBuffer ; 打印行号和内容
    inc    linesToPrint
    jmp    PrintPageLoop
DonePrintingPage:
    invoke crt_fclose, pFile
    invoke crt_printf, addr szPageInfoFmt, currentPage, totalPages ; 显示页码信息
    invoke StdOut, addr szPagePrompt ; 分页操作提示
    invoke _getch
    mov    charInput, eax
    ; 处理用户输入
    cmp    al, 'e'
    je     ExitPaging
    cmp    al, 'E'
    je     ExitPaging
    cmp    al, 'n'
    je     NextPage
    cmp    al, 'N'
    je     NextPage
    cmp    al, 'p'
    je     PrevPage
    cmp    al, 'P'
    je     PrevPage
    jmp    PagingLoop
NextPage:
    mov    eax, currentPage
    mov    ebx, totalPages
    cmp    eax, ebx
    jge    PagingLoop
    inc    currentPage
    jmp    PagingLoop
PrevPage:
    mov    eax, currentPage
    cmp    eax, 1
    jle    PagingLoop
    dec    currentPage
    jmp    PagingLoop
HistoryIsEmpty:
    invoke StdOut, addr szHistoryEmpty
    invoke StdOut, addr szPressAnyKey
    invoke _getch
ExitPaging:
    ret
DoViewHistory endp
```

- **统计总行数**：为了实现分页，首先需要知道总共有多少条历史记录。程序会打开文件，逐行读取并计数，然后关闭文件。
- **计算总页数**：`totalLines / PAGE_SIZE` 计算基本页数，如果 `totalLines` 不能被 `PAGE_SIZE` 整除，则需要额外一页。
- **分页主循环 (`PagingLoop`)**：
  - 每次显示一页前都会清屏。
  - **重新打开文件**：由于 `crt_fgets` 只能顺序读取，为了显示特定页，每次显示新页时都需要重新打开文件。
  - **跳过行**：根据 `currentPage` 和 `PAGE_SIZE` 计算出 `linesToSkip`，然后循环调用 `crt_fgets` 跳过这些行。
  - **打印当前页**：跳过指定行后，继续调用 `crt_fgets` 读取 `PAGE_SIZE` 条记录并打印出来。
  - **用户交互**：打印页码信息和操作提示 (`(N)ext, (P)revious, (E)xit`)。`_getch` 读取用户按键。
  - **翻页逻辑**：根据用户输入的字符（'N'/'n'、'P'/'p'、'E'/'e'）来更新 `currentPage` 或退出。



### 5.5 显示全部历史（用于组合）(`DoViewHistory_DisplayOnly`)



Code snippet

```
DoViewHistory_DisplayOnly proc
    LOCAL  pFile:DWORD
    LOCAL  lineNum:DWORD
    invoke crt_system, addr szCls
    invoke StdOut, addr szHistoryHeader
    invoke crt_fopen, addr szHistoryFile, addr szFileReadMode
    mov    pFile, eax
    test   eax, eax
    jz     HistoryIsEmpty
    mov    lineNum, 0
PrintLineLoop:
    invoke crt_fgets, addr lineBuffer, sizeof lineBuffer, pFile
    test   eax, eax
    jz     EndOfFile
    inc    lineNum
    mov    eax, lineNum
    invoke crt_printf, addr szHistoryLineFmt, eax, addr lineBuffer
    jmp    PrintLineLoop
EndOfFile:
    invoke crt_fclose, pFile
    ret
HistoryIsEmpty:
    invoke StdOut, addr szHistoryEmpty
    ret
DoViewHistory_DisplayOnly endp
```

- 这个过程是 `DoViewHistory` 的一个简化版本，它不进行分页，而是从头到尾读取并打印 `history.txt` 中的所有行。
- 它的主要目的是在用户选择“组合历史”功能时，让用户能完整地看到所有历史记录及其对应的行号，方便选择。

------



## 6. 历史组合运算 (`DoHistoryCalculation`)



Code snippet

```
DoHistoryCalculation proc
    LOCAL  selNum1:DWORD
    LOCAL  selNum2:DWORD
    call   DoViewHistory_DisplayOnly ; 显示全部历史（无分页）
    invoke StdOut, addr szCombinePrompt ; 提示输入
    invoke ReadConsoleA, hConsoleInput, addr cInputBuffer, sizeof cInputBuffer, addr dwCharsRead, NULL
    invoke crt_sscanf, addr cInputBuffer, addr szCombineFmt, addr selNum1, addr selNum2 ; 解析输入
    cmp    eax, 2
    jne    InvalidSelection
    invoke GetHistoryLine, selNum1, addr line1Buffer
    test   eax, eax
    jz     InvalidSelection
    invoke GetHistoryLine, selNum2, addr line2Buffer
    test   eax, eax
    jz     InvalidSelection
    ; 构造 (A) * (B) 表达式
    invoke crt_strcpy, addr szExprBuffer, addr szParenOpen
    invoke crt_strcat, addr szExprBuffer, addr line1Buffer
    invoke crt_strcat, addr szExprBuffer, addr szParenClose
    invoke crt_strcat, addr szExprBuffer, addr szMultiplySign
    invoke crt_strcat, addr szExprBuffer, addr szParenOpen
    invoke crt_strcat, addr szExprBuffer, addr line2Buffer
    invoke crt_strcat, addr szExprBuffer, addr szParenClose
    invoke crt_printf, addr szCombinedExpr, addr szExprBuffer ; 显示组合表达式
    call   PerformCalculation ; 计算并显示步骤
    jmp    CalcCombineExit
InvalidSelection:
    invoke StdOut, addr szInvalidSel
CalcCombineExit:
    invoke StdOut, addr szPressAnyKey
    invoke _getch
    ret
DoHistoryCalculation endp
```

- **显示历史**：调用 `DoViewHistory_DisplayOnly` 让用户看到所有可用的历史记录行号。
- **读取组合输入**：提示用户输入两个行号，例如 "2,5"。
- **解析输入**：`crt_sscanf` 用于解析用户输入的字符串，将其中的两个数字提取到 `selNum1` 和 `selNum2`。`cmp eax, 2` 检查是否成功解析了两个数字。
- **获取表达式**：两次调用 `GetHistoryLine`，分别根据 `selNum1` 和 `selNum2` 获取对应的历史表达式，存储到 `line1Buffer` 和 `line2Buffer`。
- **构造新表达式**：使用 `crt_strcpy` 和 `crt_strcat` 字符串函数，将两个获取到的表达式组合成 `(Expr1) * (Expr2)` 的形式，存储到 `szExprBuffer`。
- **计算**：调用 `PerformCalculation` 对这个新构造的表达式进行计算，并显示结果和步骤。

------

通过上述对每个功能模块的详细讲解，你应该能更好地理解这个 MASM 汇编计算器的工作原理了。这个程序展示了汇编语言在底层文件操作、字符串处理、浮点运算以及算法实现方面的强大能力。