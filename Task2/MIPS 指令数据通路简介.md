### MIPS 指令格式简介



为了更好地理解数据通路，我们首先回顾一下相关的 MIPS 指令格式：

1. **R-Type (寄存器类型)**: 用于 `addu`, `subu`, `add`, `sub`
   - `op (6) | rs (5) | rt (5) | rd (5) | shamt (5) | funct (6)`
   - 指令操作码 `op` 为 `0x00`，具体操作由功能码 `funct` 决定。
   - `rs` 和 `rt` 是源寄存器，`rd` 是目标寄存器。
2. **I-Type (立即数类型)**: 用于 `ori`, `lw`, `sw`, `beq`, `lui`
   - `op (6) | rs (5) | rt (5) | immediate (16)`
   - `rs` 是源寄存器，`rt` 是另一个源寄存器或目标寄存器。
   - `immediate` 是一个16位的立即数。

### 各指令的功能与数据通路分析

#### 1. `add` (有符号加法) 和 `addu` (无符号加法)

```
add rd, rs, rt` / `addu rd, rs, rt
```

- **指令功能**:
  - `add`: 将寄存器 `rs` 和 `rt` 中的值作为有符号数相加，如果结果发生溢出，则产生一个溢出异常。结果存入寄存器 `rd`。
  - `addu`: 将寄存器 `rs` 和 `rt` 中的值作为无符号数相加，不检查溢出。结果存入寄存器 `rd`。在实际使用中，因为不产生异常，`addu` 也常被用于通用的32位整数加法。
- **数据通路**:
  1. **取指 (Instruction Fetch)**:
     - 程序计数器 `PC` 将当前指令的地址发送到指令存储器 `IM`。
     - `IM` 根据地址，从内部ROM中读取32位的指令码。
     - 同时，`PC` 的值与 `4` 相加（通过PC+4加法器），得到下一条指令的地址，准备在下一个周期写入 `PC`（除非发生分支或跳转）。
  2. **译码与读寄存器 (Decode & Register Fetch)**:
     - `IM` 输出的指令码被送到 `Controller` (控制器) 和寄存器堆 `GRF`。
     - `Controller` 识别出 `op` 码为 `0x00` (R-Type指令)。它会产生以下主要控制信号：
       - `RegDst = 1`: 表示要写入的目标寄存器是 `rd` (指令的 `[15:11]` 位)。
       - `ALUSrc = 0`: 表示送入 `ALU` 的第二个操作数来自寄存器堆 (`RD2`)，而不是立即数。
       - `MemtoReg = 0`: 表示写回寄存器的数据来自 `ALU` 的计算结果。
       - `RegWrite = 1`: 表示需要将结果写回寄存器堆。
       - `MemRead = 0`, `MemWrite = 0`: 不访问数据存储器。
       - `Branch = 0`: 不是分支指令。
       - `ALUOp = 10` (二进制): 告诉 `ALU` 控制单元，这是一个R-Type指令。
     - 指令中的 `rs` (`[25:21]`) 和 `rt` (`[20:16]`) 地址被送到 `GRF`，`GRF` 将这两个寄存器中的值分别读出到 `RD1` 和 `RD2` 数据通路。
  3. **执行 (Execute)**:
     - `ALU` 控制单元接收到 `ALUOp = 10` 和指令的功能码 `funct` (`add` 为 `100000`，`addu` 为 `100001`)，然后生成最终的 `ALU` 操作码，命令 `ALU` 执行加法操作。
     - `RD1` 的值作为 `ALU` 的第一个输入。
     - `ALUSrc = 0`，所以 `RD2` 的值通过多路选择器后，作为 `ALU` 的第二个输入。
     - `ALU` 计算 `RD1 + RD2`，并将结果输出。对于 `add` 指令，如果发生溢出，`ALU` 的 `Overflow` 标志位会置1，触发异常。
  4. **访存 (Memory Access)**:
     - 由于 `MemRead` 和 `MemWrite` 都为0，数据存储器 `DM` 在此周期不执行任何读写操作。
  5. **写回 (Write Back)**:
     - `MemtoReg = 0`，所以 `ALU` 的计算结果通过多路选择器，被送到 `GRF` 的写数据端口 `WD`。
     - `RegDst = 1`，所以指令中的 `rd` 字段 (`[15:11]`) 通过多路选择器，被送到 `GRF` 的写地址端口 `WA`。
     - `RegWrite = 1`，`GRF` 将 `WD` 的数据写入到 `WA` 指定的寄存器中。



#### 2. `sub` (有符号减法) 和 `subu` (无符号减法)



```
sub rd, rs, rt` / `subu rd, rs, rt
```

- **指令功能**:
  - `sub`: 将寄存器 `rs` 的值减去寄存器 `rt` 的值（作为有符号数），如果结果发生溢出，则产生一个溢出异常。结果存入寄存器 `rd`。
  - `subu`: 将寄存器 `rs` 的值减去寄存器 `rt` 的值（作为无符号数），不检查溢出。结果存入寄存器 `rd`。
- **数据通路**:
  - 数据通路与 `add/addu` 完全相同，唯一的区别在 **执行** 阶段：
    - **执行 (Execute)**: `ALU` 控制单元根据 `funct` 码 (`sub` 为 `100010`，`subu` 为 `100011`) 命令 `ALU` 执行减法操作，计算 `RD1 - RD2`。对于 `sub` 指令，会进行溢出检查。

#### 3. `ori` (或立即数)

```
ori rt, rs, immediate
```

- **指令功能**:
  - 将寄存器 `rs` 中的值与一个16位的立即数 `immediate` 进行 **按位或 (OR)** 运算。在运算前，该立即数会被 **零扩展** (高16位补0) 到32位。结果存入寄存器 `rt`。
- **数据通路**:
  1. **取指**: 同上。
  2. **译码与读寄存器**:
     - `Controller` 识别 `ori` 的 `op` 码 (`001101`)。
       - `RegDst = 0`: 目标寄存器是 `rt` (指令的 `[20:16]` 位)。
       - `ALUSrc = 1`: `ALU` 的第二个操作数来自立即数。
       - `MemtoReg = 0`: 写回数据来自 `ALU`。
       - `RegWrite = 1`: 需要写回。
       - `MemRead = 0`, `MemWrite = 0`: 不访存。
       - `EXTOp = 0` (根据您的设计，假设0为零扩展): 告诉 `EXT` 扩展单元对立即数进行零扩展。
     - `GRF` 根据 `rs` 地址 (`[25:21]`) 读取寄存器的值到 `RD1`。`rt` 字段 (`[20:16]`) 将作为目标寄存器地址。
  3. **执行**:
     - 指令中的16位 `immediate` (`[15:0]`) 被送入 `EXT` 单元，进行零扩展成32位。
     - `ALUSrc = 1`，所以这个32位的零扩展立即数通过多路选择器，成为 `ALU` 的第二个输入。
     - `ALU` 控制单元根据 `ALUOp` 命令 `ALU` 执行 **逻辑或 (OR)** 操作。
     - `ALU` 计算 `RD1 | zero_extended_immediate`。
  4. **访存**: 无操作。
  5. **写回**:
     - `ALU` 的计算结果通过 `MemtoReg` 多路选择器。
     - `RegDst = 0`，所以 `rt` 字段 (`[20:16]`) 成为 `GRF` 的写地址。
     - `GRF` 将 `ALU` 结果写入 `rt` 寄存器。

#### 4. `lw` (加载字)

```
lw rt, offset(rs)
```

- **指令功能**:
  - 从内存中加载一个32位的字到寄存器 `rt` 中。内存地址由基地址寄存器 `rs` 的内容加上16位的有符号偏移量 `offset` 计算得出。
- **数据通路**:
  1. **取指**: 同上。
  2. **译码与读寄存器**:
     - `Controller` 识别 `lw` 的 `op` 码 (`100011`)。
       - `RegDst = 0`: 目标寄存器是 `rt`。
       - `ALUSrc = 1`: `ALU` 第二个操作数是立即数（偏移量）。
       - `MemtoReg = 1`: 写回数据来自**数据存储器 `DM`**。
       - `RegWrite = 1`: 需要写回。
       - `MemRead = 1`: 需要从 `DM` 读数据。
       - `MemWrite = 0`: 不需要写 `DM`。
       - `EXTOp = 1` (假设1为符号扩展): 对偏移量进行符号扩展。
       - `ALUOp = 00`: 告诉 `ALU` 控制单元执行加法（计算地址）。
     - `GRF` 根据 `rs` 地址读取基地址到 `RD1`。
  3. **执行**:
     - 16位 `offset` (`[15:0]`) 被 `EXT` 单元进行 **符号扩展** 成32位。
     - `ALUSrc = 1`，这个符号扩展后的偏移量成为 `ALU` 的第二个输入。
     - `ALU` 执行加法，计算出有效内存地址 `RD1 + sign_extended_offset`。
  4. **访存**:
     - `ALU` 计算出的地址被送到数据存储器 `DM` 的地址端口。
     - `MemRead = 1`，`DM` 从该地址读取32位数据。
  5. **写回**:
     - `MemtoReg = 1`，所以从 `DM` 读出的数据（而不是 `ALU` 结果）通过多路选择器，被送到 `GRF` 的写数据端口 `WD`。
     - `RegDst = 0`，所以 `rt` 字段成为写地址。
     - `GRF` 将从内存加载的数据写入 `rt` 寄存器。

#### 5. `sw` (存储字)

```
sw rt, offset(rs)
```

- **指令功能**:
  - 将寄存器 `rt` 中的32位数据存储到内存中。内存地址的计算方式与 `lw` 相同，由基地址 `rs` 加上有符号偏移量 `offset` 得出。
- **数据通路**:
  1. **取指**: 同上。
  2. **译码与读寄存器**:
     - `Controller` 识别 `sw` 的 `op` 码 (`101011`)。
       - `ALUSrc = 1`: `ALU` 第二个操作数是立即数。
       - `MemWrite = 1`: 需要向 `DM` 写数据。
       - `RegWrite = 0`: **不**需要写回寄存器。
       - `MemRead = 0`: 不需要读 `DM`。
       - `EXTOp = 1` (符号扩展)。
       - `ALUOp = 00` (加法)。
     - `GRF` 读取 `rs` 的值到 `RD1` (基地址)，并读取 `rt` 的值到 `RD2` (要存储的数据)。
  3. **执行**:
     - 与 `lw` 相同，`ALU` 计算出有效内存地址 `RD1 + sign_extended_offset`。
  4. **访存**:
     - `ALU` 的结果送到 `DM` 的地址端口。
     - 从 `GRF` 读出的 `RD2` 的值被送到 `DM` 的写数据端口。
     - `MemWrite = 1`，`DM` 将 `RD2` 的数据写入到计算出的地址中。
  5. **写回**: `RegWrite = 0`，无操作。

#### 6. `beq` (相等则分支)

```
beq rs, rt, label
```

- **指令功能**:
  - 比较寄存器 `rs` 和 `rt` 的值。如果两个值相等，则程序跳转到 `label` 指定的位置。`label` 是一个相对地址，其目标地址通过将指令中的16位偏移量符号扩展、左移两位后与当前 `PC+4` 的值相加得到。
- **数据通路**:
  1. **取指**: 同上。PC+4的值被计算出来。
  2. **译码与读寄存器**:
     - `Controller` 识别 `beq` 的 `op` 码 (`000100`)。
       - `ALUSrc = 0`: 比较两个寄存器的值。
       - `Branch = 1`: 这是一个分支指令。
       - `RegWrite = 0`: 不写寄存器。
       - `MemRead = 0`, `MemWrite = 0`: 不访存。
       - `ALUOp = 01` (减法)。
     - `GRF` 读取 `rs` 和 `rt` 的值到 `RD1` 和 `RD2`。
  3. **执行**:
     - `ALU` 执行减法 `RD1 - RD2`。
     - 如果结果为0（即 `rs` 的值等于 `rt` 的值），`ALU` 的 `Zero` 标志位置1。
  4. **访存与PC更新**:
     - **访存无操作**。
     - **PC更新**：
       - 指令中的16位 `immediate` (label的偏移) 被符号扩展并 **左移两位**，然后与 `PC+4` 相加，得到分支目标地址。
       - `Branch` 信号 (为1) 与 `ALU` 的 `Zero` 信号相与（AND）。
       - 如果与门结果为1 (即分支条件成立)，则选择**分支目标地址**作为下一个PC值。
       - 如果与门结果为0 (即分支条件不成立)，则选择 **PC+4** 作为下一个PC值。



#### 7. `lui` (高位立即数加载)

```
lui rt, immediate
```

- **指令功能**:
  - 将16位的立即数 `immediate` 加载到目标寄存器 `rt` 的 **高16位**。寄存器 `rt` 的 **低16位** 被清零。这条指令通常与 `ori` 配合使用，来构造任意的32位常数。
- **数据通路**:
  1. **取指**: 同上。
  2. **译码与读寄存器**:
     - `Controller` 识别 `lui` 的 `op` 码 (`001111`)。
       - `RegWrite = 1`: 需要写回。
       - `RegDst = 0`: 目标是 `rt`。
       - `MemtoReg` 会被设为一个特殊值（例如 `10` 二进制），以选择 `lui` 的专用通路。
     - `GRF` 不需要读取任何操作数。
  3. **执行/立即数处理**:
     - 指令中的16位 `immediate` (`[15:0]`) 被 **左移16位**，低16位补0，形成一个32位数。这个操作由一个专用的 `Shifter` 或硬连线完成。
     - 这个32位数被直接送往最终的写回多路选择器的一个输入端。
  4. **访存**: 无操作。
  5. **写回**:
     - `MemtoReg` 选择器选择这个移位后的立即数。
     - `RegDst = 0` 选择 `rt` 作为写地址。
     - `GRF` 将这个32位数写入 `rt` 寄存器。



#### 8. `nop` (无操作)

```
nop
```

- **指令功能**:
  - `No Operation` 的缩写。这条指令不执行任何操作，不会改变任何寄存器或内存的值。它的唯一作用就是将 `PC` 递增4，占用一个时钟周期。常用于流水线中的延迟或填充。
- **数据通路**:
  - `nop` 通常被汇编器实现为 `sll $0, $0, 0` (逻辑左移0号寄存器0位，结果存入0号寄存器)。
  - 这是一条R-Type指令，其 `op`=0, `rs`=0, `rt`=0, `rd`=0, `shamt`=0, `funct`=0。
  - **数据通路** 和 `addu` 类似，但是：
    - **读寄存器**: `GRF` 读取 `$0` 寄存器的值（总是0）到 `RD1` 和 `RD2`。
    - **执行**: `ALU` 对 0 进行0位的逻辑左移，结果还是0。
    - **写回**: `RegWrite` 为1, `RegDst` 为1，目标寄存器地址是 `rd` 字段，也是0。所以 `ALU` 的结果0被尝试写入 `$0` 寄存器。
  - **最终效果**: 由于 `$0` 寄存器是硬编码为0的，不能被修改，所以这条指令执行前后，处理器的任何寄存器/内存状态都没有改变。PC正常更新到PC+4，指令被成功“跳过”。